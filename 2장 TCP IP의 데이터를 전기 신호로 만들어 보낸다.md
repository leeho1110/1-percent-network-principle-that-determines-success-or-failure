# 2장: TCP/IP의 데이터를 전기 신호로 만들어 보낸다

### 1. 소켓을 작성한다

- 소켓을 생성하고 커넥션 연결을 담당하는 프로토콜 스택은 제어 정보를 위한 메모리 영역을 별도로 가지며, 제어 정보를 기록합니다.
    - 제어 정보는 통신 상대의 IP 주소, 포트 번호, 통신 동작의 진행 상태입니다.
    - 송신 동작 중에는 송신 이후 응답을 기다리는 동작도 포함됩니다. 응답이 돌아오지 않은 경우, 송신이 온전하지 않다고 판단 하에 재전송을 수행해야 합니다.
        - 이를 위해선 대기 시간이 필요하기에 소켓에는 응답 여부와 송신 후 경과 시간이 기록되어 있습니다.
- 애플리케이션은 `socket` 을 호출해 프로토콜 스택에 소켓 생성을 의뢰합니다.
    - 프로토콜 스택은 소켓의 제어 정보를 기록할 메모리 공간을 확보합니다.
    - 소켓별로 기록되는 정보가 다르기에 해당 요청에서는 소켓 1개 분량의 메모리만 준비합니다.
    - 소켓이 생성될 때 기록되는 정보는 초기 상태임을 나타냅니다.
    - 생성 시 반환되는 디스크립터를 애플리케이션에 전달합니다. 애플리케이션이 데이터 송수신을 위해 프로토콜 스택과 상호작용할 때 전달됩니다.
        - 디스크립터는 소켓의 제어 정보를 추상화합니다.

---

### 2. 서버에 접속한다

- 소켓을 생성하고 애플리케이션은 `connect` 를 호출해 TCP Connection을 생성합니다.
    - 소켓은 이더넷 혹은 무선 LAN 위에서 동작합니다. 이는 소켓에서 데이터를 송신하면 곧바로 케이블을 통해 데이터가 전송될 수 있다는 것을 의미합니다.
    - 하지만 소켓 생성 직후, 소켓은 프로토콜 스택에 ‘누구’와 데이터를 송수신할 것인지 먼저 알려야 합니다. 이를 **‘접속 동작’** 이라고 합니다.
    - 접속 동작의 첫 번째는 상대방과 제어 정보를 주고 받으며 송수신이 가능한 상태로 만드는 것입니다.
        - 이 때 송수신 데이터는 일시적으로 ‘버퍼 메모리’ 라는 메모리에 저장됩니다.
    - 접속 동작에서 주고 받는 제어 정보는 TCP 헤더를 의미합니다.
        - 우리가 생각하는 **SYN → SYN + ACK → ACK** 순서의 TCP 세그먼트의 헤더가 맞습니다. 정확하게는 컨트롤 비트가 SYN, SYN과 ACK, ACK로 매핑된 3개의 세그먼트입니다.
    - TCP 헤더 외에 제어 정보는 소켓에 기록되는 제어 정보는 상대편에서 볼 수 없습니다.

---

### 3. 데이터를 송수신한다

- TCP Connection이 맺어진 이후 애플리케이션은 `write` 를 호출해 프로토콜 스택에게 데이터 송신을 의뢰합니다.
    - 프로토콜 스택이 송신할 대상으로 바라보는 데이터는 **1바이트씩 차례로 나열된 단순한 바이너리**입니다.
    - 송신 시 내부 송신용 버퍼 메모리에 먼저 저장한 뒤, 버퍼가 채워지면 송신합니다. 이 때 송신의 기준점은 한 패킷에 저장할 수 있는 최대 데이터 크기입니다. 이를 **Maximum Transmission Unit, MTU** 라고 합니다.
        - MTU는 IP 헤더가 포함된 크기입니다. 이를 제외한 **데이터(TCP 세그먼트)의 최대 길이는 Maximum Segment Size, MSS** 라고 합니다.
        - 만약 전달 받을 때마다 전송한다면 아주 작은 크기의 패킷을 여러 개 보내게 될 겁니다. 이는 네트워크 혼잡을 유발합니다.
    - 하지만 만약 애플리케이션의 성능이 하락해 MTU가 채워지기까지 시간이 너무 오래 걸리는 경우도 있습니다. 이 경우 전체 송신 동작의 **속도를 보장하기 위해 내부의 타이머를 활용해 일정 시간이 경과하면 패킷을 송신**합니다.
- 만약 애플리케이션이 송신하고자 하는 데이터가 하나의 패킷보다 크면 어떻게 해야할까요?
    - 송신 측에선 데이터를 잘게 쪼개 순서를 바이트 단위로 기억합니다. 그리고 이를 패킷의 **Sequence Number(이하 SN)** 항목에 전달합니다.
        - 크기는 패킷 크기(1,500B)에서 헤더의 길이(40B)를 빼면 알 수 있으므로 전달하지 않습니다.
        - ex) 첫번째 패킷의 SN는 (시작점이니) **1**을 가집니다. 1,500 바이트를 온전하게 전달했다면 전달된 데이터는 **1,460 바이트**입니다. 따라서 다음 패킷의 시퀀스 넘버의 값은 **1,461(1+1460)**이 됩니다.
    - 송신 데이터를 수신한 측은 **Acknowledge Number(이하 AN)** 헤더에 자신이 수신한 데이터의 크기(위 예시라면 1460)를 전달합니다. 이를 수신 확인 응답이라고 표현합니다.
    - 예시에선 SN 값이 1을 가졌습니다만, 실제로는 보안 상의 위협을 방지하기 위해 난수 값으로 시작합니다.
    - 아까 송신용 데이터는 버퍼에 저장한다고 했습니다. 만약 **자신이 보낸 SN와 대응하는 수신측 AN가 적절하지 않은 경우 패킷을 재송신**합니다.
        - TCP가 Reliability를 보장되는 이유입니다.
- 네트워크가 혼잡해 AN가 적절함에도 늦게 도착하면 어떻게 해야할까요?
    - TCP에서 AN를 기다리는 시간도 중요합니다. 이런 대기 시간을 우린 **타임아웃 값**이라고 합니다.
        - 만약 타임아웃 값이 적절하게 설정되어있지 않다면 온전하게 도착한 패킷을 중복해서 송신하는 문제가 발생합니다.
        - 또한 지연의 이유는 대부분 네트워크 혼잡이므로 패킷 재전송은 상황을 악화시킬 우려가 있습니다.
    - 따라서 TCP는 타임아웃 값을 동적으로 설정합니다.
        - 데이터 송신 시 AN가 돌아오는 시간을 매번 기록합니다. 이후 시간이 기존보다 밀리거나 당겨지는 경우 그에 맞게 대기 시간을 조절합니다.
- 항상 하나의 패킷만 보내야 할까요? 너무 느리지 않을까요?
    - 패킷을 전송한 뒤 도착할 때까지 기다리기만 하는 것은 비효율적입니다. 따라서 TCP는 패킷을 송신한 뒤 AN을 기다리지 않고 연속해 패킷을 전송합니다. 이를 올바르게 수행하기 위한 디테일이 있지만, 우선 이를 **윈도우 제어 방식**이라고 합니다.
        - 하지만 이 방식은 수신측의 허용량을 고려하지 않습니다. 정확하게는 수신 측 버퍼 사이즈를 고려하지 않죠.
    - 따라서 이를 고려하기 위해 수신 측은 패킷을 수신 + 수신 버퍼에 데이터를 저장하고, **수신 가능한 데이터의 양(버퍼의 여유 사이즈)를 윈도우 필드에 담아 송신 측에게 전달**합니다.
        - 수신 가능한 데이터 양의 최대값을 우린 **윈도우 사이즈**라고 부릅니다.
        - 윈도우 통지의 타이밍은 수신측의 애플리케이션이 버퍼 메모리에서 데이터를 꺼내갔을 때입니다. 그래야 수신 버퍼의 빈 공간이 발생하니까요.
- 데이터를 읽는 동작은 애플리케이션의 프로토콜 스택의 `read` 를 호출합니다.
    - 수신 시 데이터 조각과 TCP 헤더를 검사해 데이터 누락 여부를 검증합니다.
    - 패킷에 담긴 데이터가 조각나있을수도 있으니 잠시 수신 버퍼에 보관한 뒤, 뒤이어 도착하는 데이터들의 조각을 합쳐 원래 모습으로 복원합니다.
        - 정확하게는 수신 데이터를 애플리케이션이 지정한 메모리 영역에 옮겨서 기록한 뒤, 제어권을 되돌려줍니다.

---

### 4. 서버에서 연결을 끊어 소켓을 말소한다

- 여기선 서버 측이 먼저 연결을 끊는다고 가정합니다. 연결을 끊을 때 애플리케이션은 `close` 를 호출합니다.
    - 소켓 라이브러리에서 FIN 컨트롤 비트를 설정한 TCP 헤더를 생성하고 클라이언트에게 송신합니다.
    - 클라이언트는 수신 사실을 위해 ACK 컨트롤 비트를 설정한 패킷을 반송합니다. 그리고 프로토콜 스택에 자신의 소켓이 연결을 끊으려는 것을 기록합니다.
        - 이후 애플리케이션에선 `read` 를 호출해 데이터를 가지러 오지만, 데이터를 이미 받았기에 수신 완료라는 사실을 전달합니다.
    - 이 후 클라이언트의 애플리케이션도 데이터를 모두 수신했으므로 `close` 를 호출합니다. 이 때 서버측과 마찬가지로 FIN 컨트롤 비트를 설정한 TCP 헤더를 만들어 송신합니다.
        - 서버에서 ACK 이 도착하면 서버와의 연결이 종료됩니다.
    - 하지만 이 때 해제 요청을 받은 클라이언트는 연결을 바로 종료하지 않고 잠시 대기합니다.
        - 바로 종료하지 않는 이유는 바로 **소켓이 의도치 않게 오동작해 종료되는 문제** 때문입니다.
    - 연결을 먼저 끊으려고 요청하는 Active Closer(이하 AC)와 요청을 수신하는 Passive Closer(이하 PC)의 관계에서 알아보죠
        - AC는 FIN, PC는 ACK를 송신합니다. 뒤이어 PC가 다시 FIN, AC가 ACK을 송신합니다. 만약 PC가 FIN을 보내고 나서 AC가 ACK을 송신하는 사이 FIN을 다시 보내면 어떻게 될까요?
        - 만약 PC에서 이미 소켓을 말소했다면 아마 새로운 애플리케이션의 소켓이 이전 포트에 매핑될 겁니다. 그리고 재발송된 FIN이 들어오겠죠.
        - 이렇게 같은 포트에 소켓이 만들어진 상태에서 받은 **FIN은 이전 소켓에 대한 것이지만 새로운 소켓을 종료**시켜버립니다. 따라서 이러한 오동작을 막기 위해 잠시 기다립니다.

---

### 5. IP와 이더넷의 패킷 송수신 동작

- 패킷이 운반될 때 동작하는 중계 장치는 **‘라우터’**와 **‘허브’**입니다.
    - 라우터는 L3(IP) 레벨에서 목적지를 확인하고 다음 중계 장치를 나타냅니다.
        - 라우터는 IP 헤더의 IP 주소를 사용합니다.
    - 허브는 L2(이더넷) 레벨에서 이더넷이 패킷을 중계장치까지 운반합니다.
        - 허브는 이더넷 헤더의 MAC 주소를 사용합니다.
    - 클라이언트에서 서버까지 도착하기 위해 1개 혹은 다수개의 허브, 그리고 1개 혹은 다수개의 라우터를 거쳐갑니다.
        - 다음 라우터에 도착하기 위해 여러 허브를 통과할 수 있습니다.
- 프로토콜 스택의 IP 담당 부분은 IP 헤더와 MAC 헤더를 추가로 달아줍니다.
    - 애플리케이션에서 보내려는 데이터는 바이러니 데이터입니다. 이 데이터들이 실제로 이더넷을 통해 물리적으로 전달되기 위해선 이를 전자 혹은 빛 신호로 변경되어야 합니다.
    - 이 역할을 수행하는 네트워크용 하드웨어들을 통칭하여 **LAN 어댑터**라고 부릅니다.
    - 우리가 패킷에 담아 전달하는 IP 주소는 LAN 어댑터의 주소입니다.
        - LAN 어댑터들은 하나의 컴퓨터에 여러 개를 설치할 수도 있습니다.
- 라우터에서 패킷을 건네어 줄 상대를 결정하는 기준은 **경로표**입니다.
    - 경로표에서 비교하는 값은 **넷마스크를 통해 추출한 네트워크 번호**입니다.
- MAC 헤더에서 헤더의 종류를 나타내기 위해 사용되는 **이더 타입은 사용하는 프로토콜에 따라 달라집니다.**
- IP 레벨에서 패킷을 건네줄 때 우린 실제로 어느 LAN 어댑터가 수신해야하는지 알아야 합니다. 하지만 L2에선 알 수 없습니다. 이를 해결하기 위해 **ARP를 활용**합니다.
    - ARP는 Address Resolution Protocol의 약자로 브로드캐스트를 통해 특정 IP 주소를 소유하는 LAN 어댑터의 MAC 주소를 탐색합니다.
    - 탐색이 완료되면 **ARP 캐시**라는 메모리 영역에 보존해 재사용합니다.
        - ARP 캐시는 최신화를 위해 일반적으로 몇 분 정도만 재사용합니다.
- 이더넷은 기술이 발전하며 여러 형태로 발전했습니다.
    - 여러 호스트가 트랜시버 케이블을 통해 트렁크 케이블에 묶여있는 10BASE5
    - 신호를 흩뿌리는 동작을 수행하는 리피터 허브를 이용한 파생형 10BASE-T
    - 수신처 MAC 주소에 따라 목적지를 확인하고 패킷을 원하는 상대에게만 중계하는 스위칭 허브
- 이전에 우리가 보내려는 바이너리 데이터를 실제 전기 신호로 변환하는 동작은 LAN 어댑터가 수행한다고 얘기했습니다. 자세히 알아보죠.
    - 우선 LAN 어댑터는 하드웨어와 상호작용하기 위해 드라이버가 필요합니다. 이를 LAN 드라이버라고 합니다.
        - 네트워크 어댑터 드라이버 또는 이더넷 드라이버라고도 하는 LAN 드라이버는 컴퓨터 운영 체제와 LAN(로컬 영역 네트워크) 하드웨어 간의 통신을 가능하게 하는 소프트웨어 구성 요소입니다.
        - 이 드라이버는 컴퓨터가 LAN 연결을 통해 데이터를 주고받을 수 있도록 하는 번역기 역할을 합니다.
    - 이 때 LAN 드라이버는 패킷을 수신하면 LAN 어댑터의 버퍼 메모리에 복사한 뒤, **패킷을 송신하는 역할을 수행하는 MAC 회로에게 명령을 송신**합니다.
        - MAC 회로는 송신 패킷을 추출한 뒤 맨 앞에 **프리앰블, 스타트 프레임 딜리미터**를 추가하고, 맨 끝에는 오류 검출용 데이터인 **프레임 체크 시퀀스(FCS)**를 추가합니다.
        - 프리앰블은 송신하는 패킷을 읽을 타이밍을 위해서 존재합니다.
        - 스타트 프레임 딜리미터는 패킷의 시작점을 표시하기 위해 존재합니다.
        - FCS는 패킷 운반 도중 잡음 등의 영향으로 발생하는 파형의 변경을 검출하기 위해 사용합니다.
- 패킷이 완성되면 허브의 종류에 따라 신호 송신 모드가 달라집니다.
    - 리피터 허브를 사용할 때 동작하는 반이중 모드는 케이블에 다른 기기의 송신 신호가 이미 존재하는지 검사하고, 흐르지 않을 때 송신합니다.
        - 만약 충돌이 발생한 경우 **다른 기기에 충돌 사실을 알리기 위해** **재밍 신호**를 잠시 흘리고 재송신합니다.
    - 스위칭 허브를 사용할 때 동작하는 전이중 모드는 송수신 신호를 동시에 받고 보냅니다. 전이중 모드는 반이중 모드와 다르게 충돌이 일어나지 않습니다.
- 반이중 동작에서 패킷을 수신할 때의 과정은 아래와 같습니다.
    - 먼저 프리앰블을 통해 파형에서 읽을 타이밍을 계산합니다. 이 후 스타트 프레임 딜리미터가 나오면 그 뒤를 디지털 데이터로 변환합니다.
        - 송신 시에는 MAC 회로에서 PHY 회로로 진행했지만, 수신은 반대입니다.
    - 변환된 디지털 데이터는 버퍼 메모리에 저장됩니다. 저장한 뒤 FCS를 검사했을 때 정상이라면 유지하고 만약 문제가 있는 경우 폐기합니다.
    - 이 후 MAC 헤더의 수신처 MAC를 확인해 자신의 것인지 판단합니다.
        - 만약 자신의 것이라면 패킷을 버퍼 메모리에 저장합니다. 이후 패킷 수신을 통보합니다.
        - 통지는 **인터럽트 구조를 사용**합니다. 인터럽트를 통해 CPU가 LAN 어댑터를 제어해 패킷을 추출할 수 있도록 합니다.
- 프로토콜 스택의 IP 담당 부분은 인터럽트를 통해 수신한 패킷에서 데이터를 추출합니다.
    - 우선 헤더부터 유효성 검증을 실시하고, 만약 수신처 IP 주소가 자신의 주소가 아니라면 오류라고 판단합니다.
        - 이 경우 ICMP 메시지를 사용해 통신 상대에게 오류 사실을 통지합니다.
    - 만약 정상이라면 **패킷이 조각나 보내지는 프래그먼테이션(fragementation)**의 경우를 대처하기 위해 아래 절차를 수행합니다.
        - IP 헤더에 플래그를 확인해 수신 패킷의 분할 여부를 판단합니다. 이 후 ID 정보에 동일한 값을 갖는 패킷을 대기합니다.
        - 만약 동일한 패킷을 수신한 경우 프래그먼트 오프셋 항목을 참조해 분할된 패킷을 원래대로 되돌립니다. 이 작업을 리어셈블링이라고 합니다.

---