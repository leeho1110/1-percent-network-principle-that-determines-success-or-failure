# 2장: TCP/IP의 데이터를 전기 신호로 만들어 보낸다

### 1. 소켓을 작성한다

- 소켓을 생성하고 커넥션 연결을 담당하는 프로토콜 스택은 제어 정보를 위한 메모리 영역을 별도로 가지며, 제어 정보를 기록합니다.
    - 제어 정보는 통신 상대의 IP 주소, 포트 번호, 통신 동작의 진행 상태입니다.
    - 송신 동작 중에는 송신 이후 응답을 기다리는 동작도 포함됩니다. 응답이 돌아오지 않은 경우, 송신이 온전하지 않다고 판단 하에 재전송을 수행해야 합니다.
        - 이를 위해선 대기 시간이 필요하기에 소켓에는 응답 여부와 송신 후 경과 시간이 기록되어 있습니다.
- 애플리케이션은 `socket` 을 호출해 프로토콜 스택에 소켓 생성을 의뢰합니다.
    - 프로토콜 스택은 소켓의 제어 정보를 기록할 메모리 공간을 확보합니다.
    - 소켓별로 기록되는 정보가 다르기에 해당 요청에서는 소켓 1개 분량의 메모리만 준비합니다.
    - 소켓이 생성될 때 기록되는 정보는 초기 상태임을 나타냅니다.
    - 생성 시 반환되는 디스크립터를 애플리케이션에 전달합니다. 애플리케이션이 데이터 송수신을 위해 프로토콜 스택과 상호작용할 때 전달됩니다.
        - 디스크립터는 소켓의 제어 정보를 추상화합니다.

---

### 2. 서버에 접속한다

- 소켓을 생성하고 애플리케이션은 `connect` 를 호출해 TCP Connection을 생성합니다.
    - 소켓은 이더넷 혹은 무선 LAN 위에서 동작합니다. 이는 소켓에서 데이터를 송신하면 곧바로 케이블을 통해 데이터가 전송될 수 있다는 것을 의미합니다.
    - 하지만 소켓 생성 직후, 소켓은 프로토콜 스택에 ‘누구’와 데이터를 송수신할 것인지 먼저 알려야 합니다. 이를 **‘접속 동작’** 이라고 합니다.
    - 접속 동작의 첫 번째는 상대방과 제어 정보를 주고 받으며 송수신이 가능한 상태로 만드는 것입니다.
        - 이 때 송수신 데이터는 일시적으로 ‘버퍼 메모리’ 라는 메모리에 저장됩니다.
    - 접속 동작에서 주고 받는 제어 정보는 TCP 헤더를 의미합니다.
        - 우리가 생각하는 **SYN → SYN + ACK → ACK** 순서의 TCP 세그먼트의 헤더가 맞습니다. 정확하게는 컨트롤 비트가 SYN, SYN과 ACK, ACK로 매핑된 3개의 세그먼트입니다.
    - TCP 헤더 외에 제어 정보는 소켓에 기록되는 제어 정보는 상대편에서 볼 수 없습니다.

---

### 3. 데이터를 송수신한다

- TCP Connection이 맺어진 이후 애플리케이션은 `write` 를 호출해 프로토콜 스택에게 데이터 송신을 의뢰합니다.
    - 프로토콜 스택이 송신할 대상으로 바라보는 데이터는 **1바이트씩 차례로 나열된 단순한 바이너리**입니다.
    - 송신 시 내부 송신용 버퍼 메모리에 먼저 저장한 뒤, 버퍼가 채워지면 송신합니다. 이 때 송신의 기준점은 한 패킷에 저장할 수 있는 최대 데이터 크기입니다. 이를 **Maximum Transmission Unit, MTU** 라고 합니다.
        - MTU는 IP 헤더가 포함된 크기입니다. 이를 제외한 **데이터(TCP 세그먼트)의 최대 길이는 Maximum Segment Size, MSS** 라고 합니다.
        - 만약 전달 받을 때마다 전송한다면 아주 작은 크기의 패킷을 여러 개 보내게 될 겁니다. 이는 네트워크 혼잡을 유발합니다.
    - 하지만 만약 애플리케이션의 성능이 하락해 MTU가 채워지기까지 시간이 너무 오래 걸리는 경우도 있습니다. 이 경우 전체 송신 동작의 **속도를 보장하기 위해 내부의 타이머를 활용해 일정 시간이 경과하면 패킷을 송신**합니다.
- 만약 애플리케이션이 송신하고자 하는 데이터가 하나의 패킷보다 크면 어떻게 해야할까요?
    - 송신 측에선 데이터를 잘게 쪼개 순서를 바이트 단위로 기억합니다. 그리고 이를 패킷의 **Sequence Number(이하 SN)** 항목에 전달합니다.
        - 크기는 패킷 크기(1,500B)에서 헤더의 길이(40B)를 빼면 알 수 있으므로 전달하지 않습니다.
        - ex) 첫번째 패킷의 SN는 (시작점이니) **1**을 가집니다. 1,500 바이트를 온전하게 전달했다면 전달된 데이터는 **1,460 바이트**입니다. 따라서 다음 패킷의 시퀀스 넘버의 값은 **1,461(1+1460)**이 됩니다.
    - 송신 데이터를 수신한 측은 **Acknowledge Number(이하 AN)** 헤더에 자신이 수신한 데이터의 크기(위 예시라면 1460)를 전달합니다. 이를 수신 확인 응답이라고 표현합니다.
    - 예시에선 SN 값이 1을 가졌습니다만, 실제로는 보안 상의 위협을 방지하기 위해 난수 값으로 시작합니다.
    - 아까 송신용 데이터는 버퍼에 저장한다고 했습니다. 만약 **자신이 보낸 SN와 대응하는 수신측 AN가 적절하지 않은 경우 패킷을 재송신**합니다.
        - TCP가 Reliability를 보장되는 이유입니다.
- 네트워크가 혼잡해 AN가 적절함에도 늦게 도착하면 어떻게 해야할까요?
    - TCP에서 AN를 기다리는 시간도 중요합니다. 이런 대기 시간을 우린 **타임아웃 값**이라고 합니다.
        - 만약 타임아웃 값이 적절하게 설정되어있지 않다면 온전하게 도착한 패킷을 중복해서 송신하는 문제가 발생합니다.
        - 또한 지연의 이유는 대부분 네트워크 혼잡이므로 패킷 재전송은 상황을 악화시킬 우려가 있습니다.
    - 따라서 TCP는 타임아웃 값을 동적으로 설정합니다.
        - 데이터 송신 시 AN가 돌아오는 시간을 매번 기록합니다. 이후 시간이 기존보다 밀리거나 당겨지는 경우 그에 맞게 대기 시간을 조절합니다.
- 항상 하나의 패킷만 보내야 할까요? 너무 느리지 않을까요?
    - 패킷을 전송한 뒤 도착할 때까지 기다리기만 하는 것은 비효율적입니다. 따라서 TCP는 패킷을 송신한 뒤 AN을 기다리지 않고 연속해 패킷을 전송합니다. 이를 올바르게 수행하기 위한 디테일이 있지만, 우선 이를 **윈도우 제어 방식**이라고 합니다.
        - 하지만 이 방식은 수신측의 허용량을 고려하지 않습니다. 정확하게는 수신 측 버퍼 사이즈를 고려하지 않죠.
    - 따라서 이를 고려하기 위해 수신 측은 패킷을 수신 + 수신 버퍼에 데이터를 저장하고, **수신 가능한 데이터의 양(버퍼의 여유 사이즈)를 윈도우 필드에 담아 송신 측에게 전달**합니다.
        - 수신 가능한 데이터 양의 최대값을 우린 **윈도우 사이즈**라고 부릅니다.
        - 윈도우 통지의 타이밍은 수신측의 애플리케이션이 버퍼 메모리에서 데이터를 꺼내갔을 때입니다. 그래야 수신 버퍼의 빈 공간이 발생하니까요.
- 데이터를 읽는 동작은 애플리케이션의 프로토콜 스택의 `read` 를 호출합니다.
    - 수신 시 데이터 조각과 TCP 헤더를 검사해 데이터 누락 여부를 검증합니다.
    - 패킷에 담긴 데이터가 조각나있을수도 있으니 잠시 수신 버퍼에 보관한 뒤, 뒤이어 도착하는 데이터들의 조각을 합쳐 원래 모습으로 복원합니다.
        - 정확하게는 수신 데이터를 애플리케이션이 지정한 메모리 영역에 옮겨서 기록한 뒤, 제어권을 되돌려줍니다.

---