# 1장: 웹 브라우저

### 머릿말

- 1장은 주로 HTTP 메시지와 관련된 내용으로 이루어져 있습니다. 책을 선택한 주요 관심사는 TCP 계층과 관련된 전반적인 학습이기에, 기존에 알지 못했던 내용 혹은 중요하다고 판단되는 내용만 가볍게 정리합니다.

---

### 1. HTTP 리퀘스트 메시지를 작성한다

- 흔히 작성하는 `http://~` 에서 {http} 영역은 프로토콜을 명시합니다. 경우에 따라 `ftp://~`, `file://`, `mailto:` 가 될 수 있습니다.
- 브라우저는 가장 먼저 수행하는 일은 URL을 해독하는 일입니다.
- HTTP 1.1 버전에서 추가된 헤더 필드 중 일부입니다.
    - Cache-Control → 캐시를 제어하기 위해 사용됩니다.
    - Connection → HTTP Response 전달 이 후 TCP 커넥션의 유지 여부를 나타냅니다.
    - Transfer-Encoding → 메시지 본문 내 인코딩 방식을 표현하기 위해 사용됩니다.
    - if-Match, If-None-Match → Etag(응답 데이터에 대한 유일 식별자)와 함께 사용되는 값입니다. 응답 이후 갱신 처리에서 이전 응답을 재활용하는 경우에서 서버에 해당 여부를 전달하기 위해 사용됩니다.

---

### 2. 웹 서버의 IP 주소를 DNS 서버에 조회한다

- 인터넷 혹은 사내 LAN에서 표현하는 ‘서브넷’은 여러 호스트가 허브에 묶여있는 것을 말합니다.
    - 허브는 이더넷과 같은 L2 레이어에서 네트워크 장비들을 묶는 역할입니다. IP 수준에서의 같은 역할은 라우터입니다.
- 왜 우린 IP 주소를 사용하는 것일까요? 편리하게 도메인 이름을 사용하면 되지 않을까요?
    - IP 주소는 8비트 X 4 → 4바이트를 통해 라우팅이 가능합니다. 하지만 도메인 명을 사용한다면 최대 255 바이트까지의 문자를 처리해야 합니다. 이는 라우팅의 성능 저하를 유발하고 네트워크의 속도 저하로 이어집니다.
- IP 주소를 도메인 명으로 변환하는 기능은 DNS Resolver(이하 리졸버)가 수행합니다. 리졸버가 도메인명을 탐색하는 행위는 네임 리졸루션(Name resolution)이라고 부릅니다.
    - 리졸버는 Socket 라이브러리에 탑재되어 있습니다. 소켓 라이브러리는 OS가 포함하는 네트워크 기능을 애플리케이션에서 호출하기 위해 모아놓은 파일입니다.
    - 리졸버에서 도메인 명을 탐색하기 위해선 `gethostbyname(..)` 을 사용합니다.
        - 사실 리졸버가 직접 수행하지 않고 **OS 내 프로토콜 스택을 호출해 실행을 위임**합니다.
        - 해당 작업은 UDP 프로토콜 위에서 수행됩니다.

---

### 3. 전 세계의 DNS 서버가 연대한다

- DNS 서버는 도메인 명을 탐색하러 오는 클라이언트에 응답하기 위해 총 3가지의 정보를 포함하고 있습니다.
    - 이름, 클래스, 타입
        - 타입의 경우 IP 주소에서 이름을 조사하는 PTR, 닉네임을 위한 CNAME, DNS 서버에 IP 주소를 등록하는 NS 등이 있습니다.
    - `gethostbyname(..)` 에서 포함하는 정보도 위 3가지와 같습니다. 도메인 서버는 3가지 정보와 일치하는 등록 정보(IP 주소)를 응답합니다.
        - 응답하는 등록 정보는 리소스 레코드라고 부릅니다.
- 모든 도메인을 1대의 DNS 서버에 등록하는 것은 불가능합니다. 따라서 DNS는 ‘.’ 기호를 기준으로 분산된 형태를 띕니다.
    - 루트 도메인 DNS 서버 → com 도메인 DNS 서버, kr 도메인 DNS 서버 → glasscom 도메인 DNS 서버 → … → 가장 가까운 DNS 서버 → 클라이언트
    - 도메인 탐색은 루트 도메인부터 아래쪽으로 거슬러 내려가는 형태를 취합니다. 이 때 필요한 루트 도메인 서버의 주소는 DNS 서버들에 미리 등록해놓습니다.
    - 따라서 클라이언트가 최초 가장 가까운 DNS 서버에 요청을 보냈을 때 곧바로 루트 도메인 서버로 이동할 수 있습니다.
- DNS 서버는 빠른 응답을 위해 응답들을 캐시에 저장해놓습니다.

---

### 4. 프로토콜 스택에 메시지 송신을 의뢰한다

- HTTP 메시지는 디지털 데이터입니다. 이런 데이터들은 소켓 라이브러리를 사용해 송신 측과 수신 측 컴퓨터 사이에 파이프를 만들고, 데이터를 흘려보내는 형태로 메시지를 전달합니다.
    - 이 때 양측 컴퓨터를 잇는 **파이프의 입구를 소켓**이라고 부릅니다.
    - 연결할 때는 클라이언트 → 서버 방향이었지만, 끊을 때는 어느 쪽에서나 그낭합니다.
- 소켓을 생성하는 역할은 OS 내부의 프로토콜 스택이 수행합니다. 이 때 애플리케이션은 소켓 라이브러리를 통해 요청을 전송합니다.
    - 소켓을 만드는 동작은 `**socket(..)`** 을 호출해 수행합니다.
        - 소켓이 생성되면 소켓의 식별자 역할인 디스크럽터가 반환됩니다. 애플리케이션은 수많은 소켓이 생성됐을 때 각 소켓을 구별하기 위해 디스크럽터를 메모리에 저장하여 활용합니다.
    - 만들어진 소켓을 서버 측에 접속하도록 `**connect(..)`** 를 호출합니다.
        - 이 때 전달되는 정보는 **사용할 소켓의 디스크립터, 연결할 서버의 IP 주소, 연결할 서버의 포트 번호** 세 가지입니다.
        - 프로토콜 스택은 클라이언트의 소켓이 생성될 때 내부적으로 적당한 포트 번호를 매핑합니다.
    - 데이터를 전달하기 위해서 `**write(..)`** 를 호출합니다.
        - 애플리케이션은 데이터 전달을 위해 송신 데이터를 메모리에 위치시킵니다.
    - 데이터를 읽을 때는 `**read(..)`** 를 호출합니다.
        - 수신한 응답 메시지는 수신 버퍼에 임시로 저장됩니다. 이 후 애플리케이션이 수신 버퍼(메모리)에 접근해 데이터를 가져갑니다.
    - 생성된 소켓 연결을 종료할 땐 `**close(..)`** 를 호출합니다.